\begin{frame}{La programmation dynamique}
    \begin{block}{Principe}
        Stocker le résultat de calculs intermédiaires qui interviennent plusieurs fois dans le résultat pour éviter de les calculer plusieurs fois.
    \end{block}
    \medskip

    Dès qu'on a une formule de récurrence d'ordre 2 ou plus, on doit penser à la programmation dynamique.
\end{frame}

\begin{frame}{Exemple : la suite de Fibonacci}
    \begin{exampleblock}{Suite de Fibonacci}
        $F(0) = F(1) = 1$\\
        $F(n) = F(n-1) + F(n-2)$
    \end{exampleblock}

    \begin{center}
        \begin{tikzpicture}[
        scale=.8,
        every node/.style={draw, rounded corners, font=\small, inner sep=2pt},
        level1/.style={sibling distance=60mm},
        level2/.style={sibling distance=28mm},
        level3/.style={sibling distance=15mm},
        level4/.style={sibling distance=12mm},
        edge from parent/.style={-latex, draw}
        ]

        \node (f5) {$F(5)$}
        child[level1] { node (f4) {$F(4)$}
            child[level2] { node (f3a) {$F(3)$}
            child[level3] { node (f2a) {$F(2)$}
                child[level4] { node {$F(1)$} }
                child[level4] { node {$F(0)$} }
            }
            child[level3] { node {$F(1)$} }
            }
            child[level2] { node (f2b) {$F(2)$}
            child[level3] { node {$F(1)$} }
            child[level3] { node {$F(0)$} }
            }
        }
        child[level1] { node (f3b) {$F(3)$}
            child[level2] { node (f2c) {$F(2)$}
            child[level3] { node {$F(1)$} }
            child[level3] { node {$F(0)$} }
            }
            child[level2] { node {$F(1)$} }
        };

        % Highlight repeated subproblems
        \begin{scope}
        \node[draw, dashed, fit=(f3a)] {};
        \node[draw, dashed, fit=(f3b)] {};

        \node[draw, dashed, fit=(f2a)] {};
        \node[draw, dashed, fit=(f2b)] {};
        \node[draw, dashed, fit=(f2c)] {};
        \end{scope}

        \end{tikzpicture}
    \end{center}
\end{frame}

\lstset{language=python, keywordstyle=\ttfamily\bf\color{csred}, basicstyle=\ttfamily\footnotesize, literate={\#}{{\#}}1 {é}{{\'e}}1, showspaces=false}

\begin{frame}[fragile, allowframebreaks]{Suite de Fibonacci}
    \begin{itemize}
        \item Approche naïve (récursive)
\begin{lstlisting}
def fib(n):
  if n==1 or n==2:
    return 1
  return fib(n-1)+fib(n-2)
\end{lstlisting}
        $\Rightarrow$ complexité exponentielle $O(\phi^n)$ ($\phi$ le nombre d'or)
        \bigskip

        \item Programmation dynamique (récursive avec mémoïsation)
\begin{lstlisting}
table = {0:0, 1:1}
def fib(n):
  if not n in table:
    table[n] = fib(n-1) + fib(n-2)
  return table[n]
\end{lstlisting}
        $\Rightarrow$ complexité linéaire $O(n)$
        \framebreak

        \item Programmation dynamique (itérative avec tabulation)
\begin{lstlisting}
table = {0:0, 1:1}
def fib(n):
    for i in range(2, n+1):
        table[i] = table[i-1] + table[i-2]
    return table[n]
\end{lstlisting}
        $\Rightarrow$ complexité linéaire $O(n)$
    \end{itemize}
    \bigskip

    Dans les exemples qui suivent et dans tout le cours, on utilise la programmation dynamique itérative (\textit{bottom up}).
\end{frame}

% Définition informelle de l'algo
\begin{frame}{Bellman-Ford}
    Un exemple d'algorithme très utile utilisant la programmation dynamique :
    \medskip

    \begin{block}{Algorithme de Bellman-Ford}
        Pour des graphes \textbf{pondérés} (même à poids négatifs), l'algorithme de Bellman-Ford nous donne le poids du plus court chemin entre un n\oe{}ud de départ $s$ et tous les autres n\oe{}uds du graphe.
    \end{block}
    \medskip

    L'algorithme a une moins bonne complexité temporelle que Dijkstra mais est plus général.
\end{frame}

\begin{frame}{Bellman-Ford}
    \begin{block}{Principe de l'algorithme}
        On stocke $OPT(i,v)$ la longueur du plus court chemin entre le n\oe{}ud départ et $v$, avec au plus $i$ arêtes.
        \medskip

        À chaque étape, on regarde s'il est plus court de garder le chemin à $i-1$ arêtes, ou d'utiliser un autre chemin déjà existant vers un voisin de $v$ et d'y ajouter l'arête qui le relie à $v$. ($\star$)
        \medskip

        Complexité : $O(|V|\times|E|)$ avec une liste d'adjacence, et $O(|V|^3)$ avec une matrice d'adjacence
    \end{block}
    \medskip

    Le choix ($\star$) est traduit par la formule :
    \[
    \hspace*{-.35cm}OPT(i,v) = \min\left(OPT(i-1,v), \min_{(u,v)\in E}(OPT(i-1,u) + w((u,v)))\right)
    \]
\end{frame}

% On dira que dans le cours c'est inversé

\begin{frame}[fragile]{Bellman-Ford : algorithme}
    \begin{algorithmic}
        \Function{Bellman-Ford}{$G=(V,E,w), s\in V$}
            \State $d[0, v] \gets +\infty$ pour tout sommet $u \in V$
            \State $d[0, s] \gets 0$

            \State
            \For{i allant de $1$ à $|V|-1$}
                \For{$v \in V$}
                    \State $d[i,v] = d[i-1,v]$
                    \For{$(u,v)\in E$}
                        \If{$d[i,v]>d[i-1,u] + w(u,v)$}
                            \State $d[i,v] = d[i-1,u] + w(u,v)$
                        \EndIf
                    \EndFor
                \EndFor
            \EndFor
            \Return $d$
        \EndFunction
    \end{algorithmic}
    \bigskip

    \begin{exampleblock}{Justification de la première boucle}
        Un chemin optimal ne peut contenir que $|V|-1$ arêtes au plus, sinon on aurait une répétition de sommets dans le chemin.
    \end{exampleblock}
\end{frame}

% Démo Bellman-Ford
\begin{frame}{Bellman-Ford : exemple}
    \begin{center}
        \tikzstyle{noeud}=[draw, shape=circle, minimum size=0.15\unitlength]
        \begin{tikzpicture}[scale=1.5]
        \node[noeud] (s0) at (0,0) {\(s_0\)};
        \node[noeud] (s1) at (2,0) {\(s_1\)};
        \node[noeud] (s2) at (4,0) {\(s_2\)};
        \node[noeud] (s3) at (1,1) {\(s_3\)};
        \node[noeud] (s4) at (3,1) {\(s_4\)};
        \node[noeud, fill=red!20] (s5) at (2,2) {\(s_5\)};

        \path[<-, font=\footnotesize]
        (s0) edge             node[above]       {\(-4\)}    (s1)
        (s0) edge[bend left]  node[left]       {\(-3\)}    (s5)
        (s1) edge             node[left]           {\(-2\)}    (s4)
        (s1) edge             node[right]         {\(-1\)}    (s3)
        (s2) edge             node[above]       {\(8\)}   (s1)
        (s2) edge[bend right]  node[right]   {\(3\)}    (s5)
        (s3) edge             node[right]         {\(6\)}   (s0)
        (s3) edge             node[left]           {\(4\)}   (s5)
        (s4) edge             node[right]         {\(2\)}   (s5)
        (s4) edge             node[left]           {\(-3\)}    (s2)
        ;

        \only<3>{\draw[directed_edge, ultra thick, bend right] (s5) to (s0);}
        \only<3>{\draw[directed_edge, ultra thick] (s1) to (s0);}
        \only<4>{\draw[directed_edge, ultra thick] (s3) to (s1);}
        \only<4>{\draw[directed_edge, ultra thick] (s4) to (s1);}
        \only<5>{\draw[directed_edge, ultra thick, bend left] (s5) to (s2);}
        \only<5>{\draw[directed_edge, ultra thick] (s1) to (s2);}
        \end{tikzpicture}
    \end{center}

    \begin{center}
        {\footnotesize
            \only<2>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline
                \end{tabular}

                \phantom{$s_0 = min(\infty,min(\infty-4,0-3))$}
            }
            \only<3>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & \cellcolor{gray!25}$-3$ & & & & & \\
                    \hline
                \end{tabular}

                \medskip
                $s_0 = min(\infty,min(\infty-4,0-3))$
            }
            \only<4>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & $-3$ & \cellcolor{gray!25}$\infty$ & & & & \\
                    \hline
                \end{tabular}

                \medskip
                $s_1 = min(\infty,min(\infty-1,\infty-2))$
            }
            \only<5>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & $-3$ & $\infty$ & \cellcolor{gray!25}3 & & & \\
                    \hline
                \end{tabular}

                \medskip
                $s_2 = min(\infty,min(\infty+8,0+3))$
        }
            \only<6>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & $-3$ & $\infty$ & $3$ & $4$ & $2$ & $0$ \\
                    \hline
                \end{tabular}

                \medskip
                \emph{on finit la ligne sur le même principe}
            }
            \only<7>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & $-3$ & $\infty$ & $3$ & $4$ & $2$ & $0$ \\
                    \hline 2 & $-3$ & $0$ & $3$ & $3$ & $0$ & $0$ \\
                    \hline
                \end{tabular}

                \medskip
                \emph{puis on fait la ligne suivante}
            }
            \only<8>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & $-3$ & $\infty$ & $3$ & $4$ & $2$ & $0$ \\
                    \hline 2 & $-3$ & $0$ & $3$ & $3$ & $0$ & $0$ \\
                    \hline 3 & $-4$ & $-2$ & $3$ & $3$ & $0$ & $0$ \\
                    \hline
                \end{tabular}

                \medskip
                \emph{et ainsi de suite\ldots}
            }
            \only<9>{
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline   & $s_0$ & $s_1$ & $s_2$ & $s_3$ & $s_4$ & $s_5$ \\
                    \hline 0 & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $0$ \\
                    \hline 1 & $-3$ & $\infty$ & $3$ & $4$ & $2$ & $0$ \\
                    \hline 2 & $-3$ & $0$ & $3$ & $3$ & $0$ & $0$ \\
                    \hline 3 & $-4$ & $-2$ & $3$ & $3$ & $0$ & $0$ \\
                    \hline 4 & $-6$ & $-2$ & $3$ & $2$ & $0$ & $0$ \\
                    \hline 5 & $-6$ & $-2$ & $3$ & $0$ & $0$ & $0$ \\
                    \hline
                \end{tabular}

                \phantom{...}
            }
        }
    \end{center}
\end{frame}

\begin{frame}{Comment trouver une relation de récurrence ?}
    Comment trouver la relation de récurrence pour un problème de programmation dynamique ?

    \begin{itemize}
        \item On commence par déterminer la dimension du problème (souvent 1D ou 2D)
        \item Trouver comment passer d'un état au suivant (la formule traduit souvent un choix)
        \item Identifier les cas de base
    \end{itemize}

    \begin{exampleblock}{Subset Sum}
        \textbf{Question} : existe-t-il un sous-ensemble de $A=[a_1, a_2, ..., a_n]$ de somme $T$ ?
        \medskip

        $dp[i][s] =$ True si on peut faire la somme $s$ avec les $i$ premiers éléments
        \medskip

        Relation de récurrence : $dp[i][s] = dp[i-1][s] \lor dp[i-1][s-a_i]$
        \smallskip

        Cas de base : $dp[0][0] =$ True
    \end{exampleblock}
\end{frame}

% Points importants pour l'examen
\begin{frame}{Conclusion de la section 5}
    Choses à savoir faire pour l'examen :
    \begin{itemize}
        \item Trouver une relation de récurrence dans un problème et écrire l'algorithme itératif correspondant
        \item Modifier un algorithme récursif pour ajouter de la mémoïsation
        \item Faire tourner Bellman-Ford sur un exemple
    \end{itemize}
    \medskip

    Comment s'entraîner :
    \begin{itemize}
        \item Refaire le TD 5 (sauf la question 2.5)
    \end{itemize}
\end{frame}
